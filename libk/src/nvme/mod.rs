/// The commands module contains general NVMe command structures and command functions.
///
/// This module consists of three submodules:
///
/// * The `admin` submodule contains administrative NVMe commands, such as commands for the
/// creation and deletion of I/O submission and completion queues or running device
/// self-tests.
/// * The `mi` module contains functions for the NVMe management interface as defined in the
///     [NVM ExpressTM Management Interface](https://nvmexpress.org/wp-content/uploads/NVM-Express-Management-Interface-1.1b-2020.10.05-Ratified.pdf) specification, Revision 1.1B, as radified on October 05, 2020. This
/// module is subdivided into three modules:
///     * The `mi` module contains functions for the management interface command set, such
///     as `configuration_get`, `ses_send`, etc.
///     * The `nvm` module contains NVM command set-specific commands for the management
///    interface.
///     * The `pcie` module contains functions for the PCIe command set.
/// * The `nvm` submodule contains functions for the NVM command set, such as reading and
///     writing to non-volatile media.
mod commands;
mod queues;
/// The structs module contains various structures for NVMe
mod structs;
use crate::{
    disk::*,
    interrupts::register_interrupt_handler,
    memory::{allocate_phys_range, free_range, get_aligned_free_addr},
    pci::PciDevice,
};
use alloc::{boxed::Box, string::String};
use bit_field::BitField;
pub use commands::admin::*;
use core::mem::size_of;
use dia_semver::Semver;
use lazy_static::lazy_static;
use log::*;
use minivec::MiniVec;
use rand_core::SeedableRng;
use rand_hc::Hc128Rng;
use spin::{Mutex, RwLock};
pub use structs::*;
use voladdress::VolAddress;
use x86_64::instructions::{
    hlt,
    interrupts::{disable as disable_interrupts, enable as enable_interrupts},
    random::RdRand,
};

lazy_static! {
    static ref CONTROLLERS: Mutex<MiniVec<NvmeController>> = Mutex::new(MiniVec::new());
    static ref INTRS: RwLock<MiniVec<(u128, u16)>> = RwLock::new(MiniVec::new());
}

#[repr(u8)]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
enum NvmCommand {
    Flush = 0x00,
    Write = 0x01,
    Read = 0x02,
    WriteUncorrectable = 0x04,
    Compare = 0x05,
    WriteZeros = 0x08,
    DataSetManagement = 0x09,
    Verify = 0x0C,
    ReservationRegister = 0x0D,
    ReservationReport = 0x0E,
    ReservationAcquire = 0x11,
    ReservationRelease = 0x15,
}

/// Command request for an NVMe controller
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Default)]
pub struct Request {
    /// Queue ID for this command
    qid: usize,
    /// Actual command entry
    entry: queues::SubmissionQueueEntry,
}

/// responses generated by an NVMe controller
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd)]
pub struct Response {
    /// Queue ID that this response was in
    qid: usize,
    /// Actual controller response
    entry: queues::CompletionQueueEntry,
}

/// An NVMe controller holds memory addresses to access NVMe hardware.
#[repr(C)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NvmeController {
    version: Semver,
    /// Controller Capabilities
    cap: u64,
    /// Version
    vs: u64,
    /// Interrupt Mask Set
    intms: u64,
    /// Interrupt Mask Clear
    intmc: u64,
    /// Controller Configuration
    cc: u64,
    /// Controller Status
    csts: u64,
    /// NVM Subsystem Reset (Optional)
    nssr: u64,
    /// Admin Queue Attributes
    aqa: u64,
    /// Admin Submission Queue Base Address
    asq: u64,
    /// Admin Completion Queue Base Address
    acq: u64,
    /// Controller Memory Buffer Location (Optional)
    cmbloc: u64,
    /// Controller Memory Buffer Size (Optional)
    cmbsz: u64,
    /// Boot Partition Information (Optional)
    bpinfo: u64,
    /// Boot Partition Read Select (Optional)
    bprsel: u64,
    /// Boot Partition Memory Buffer Location (Optional)
    bpmbl: u64,
    /// Controller Memory Buffer Memory Space Control (Optional)
    cmbmsc: u64,
    /// Controller Memory Buffer Status (Optional)
    cmbsts: u64,
    /// Persistent Memory Capabilities (Optional)
    pmrcap: u64,
    /// Persistent Memory Region Control (Optional)
    pmrctl: u64,
    /// Persistent Memory Region Status (Optional)
    pmrsts: u64,
    /// Persistent Memory Region Elasticity Buffer Size (optional)
    pmrebs: u64,
    /// Persistent Memory Region Sustained Write Throughput
    pmrswtp: u64,
    /// Persistent Memory Region Controller Memory Space Control (Optional)
    pmrmsc: u64,
    /// Submission Queue 0 Tail Doorbell (Admin)
    adm_sub_tail_queue_doorbell: u64,
    /// Completion Queue 0 Head Doorbell (Admin)
    adm_comp_head_queue_doorbell: u64,
    /// Submission queue tail doorbells
    sub_tail_queue_doorbells: MiniVec<u64>,
    /// Completion queue head doorbells
    comp_head_queue_doorbells: MiniVec<u64>,
    cqs: MiniVec<queues::CompletionQueue>,
    sqs: MiniVec<queues::SubmissionQueue>,
    intline: u8,
    id: u128,
    rand: Hc128Rng,
    intrspos: usize,
}

impl NvmeController {
    /// Initializes:
    /// * The NVMe memory addresses for this controller; and
    /// * The output buffer (16KiB) for this controller.
    ///
    /// # Safety
    ///
    /// This function is unsafe because the PCI device passed in must be the correct one, or
    /// undefined behavior may result.
    pub async unsafe fn new(device: PciDevice, intrspos: usize) -> Option<Self> {
        let mut dev = Self {
            cap: device.bars.0,
            vs: device.bars.0 + 0x08,
            intms: device.bars.0 + 0x0C,
            intmc: device.bars.0 + 0x10,
            cc: device.bars.0 + 0x14,
            csts: device.bars.0 + 0x1C,
            nssr: device.bars.0 + 0x20,
            aqa: device.bars.0 + 0x24,
            asq: device.bars.0 + 0x28,
            acq: device.bars.0 + 0x30,
            cmbloc: device.bars.0 + 0x38,
            cmbsz: device.bars.0 + 0x3C,
            bpinfo: device.bars.0 + 0x40,
            bprsel: device.bars.0 + 0x44,
            bpmbl: device.bars.0 + 0x48,
            cmbmsc: device.bars.0 + 0x50,
            cmbsts: device.bars.0 + 0x58,
            pmrcap: device.bars.0 + 0xE00,
            pmrctl: device.bars.0 + 0xE04,
            pmrsts: device.bars.0 + 0xE08,
            pmrebs: device.bars.0 + 0xE0C,
            pmrswtp: device.bars.0 + 0xE10,
            pmrmsc: device.bars.0 + 0xE14,
            adm_sub_tail_queue_doorbell: device.bars.0 + 0x1000,
            adm_comp_head_queue_doorbell: device.bars.0 + 0x1003, // This isn't correct, but we'll reallocate it
            sub_tail_queue_doorbells: MiniVec::new(),
            comp_head_queue_doorbells: MiniVec::new(),
            version: Semver::new(0, 0, 0),
            intline: device.int_line,
            cqs: MiniVec::new(),
            sqs: MiniVec::new(),
            id: device.unique_dev_id,
            rand: init_rand(),
            intrspos,
        };
        let _ = allocate_phys_range(device.bars.0, device.bars.0 + 0x1003, true);
        let stride = dev.read_cap().get_bits(32..36);
        dev.adm_comp_head_queue_doorbell = device.bars.0 + (0x1000 + (4 << stride));
        let _ = allocate_phys_range(
            device.bars.0 + 0x1000 + (4 << stride),
            device.bars.0 + 0x1003 + (4 << stride),
            true,
        );
        dev.init().await;
        Some(dev)
    }

    #[inline]
    fn read_cap(&self) -> u64 {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.cap as usize) };
        mem.read()
    }

    #[inline]
    fn read_vs(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.vs as usize) };
        mem.read()
    }

    #[inline]
    fn write_intms(&self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.intms as usize) };
        mem.write(val)
    }

    #[inline]
    fn write_intmc(&mut self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.intmc as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_cc(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.cc as usize) };
        mem.read()
    }

    #[inline]
    fn write_cc(&mut self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.cc as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_csts(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.csts as usize) };
        mem.read()
    }

    #[inline]
    fn read_nssr(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.nssr as usize) };
        mem.read()
    }

    #[inline]
    fn write_nssr(&mut self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.nssr as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_aqa(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.aqa as usize) };
        mem.read()
    }

    #[inline]
    fn write_aqa(&mut self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.aqa as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_asq(&self) -> u64 {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.asq as usize) };
        mem.read()
    }

    #[inline]
    fn write_asq(&mut self, val: u64) {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.asq as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_acq(&self) -> u64 {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.acq as usize) };
        mem.read()
    }

    #[inline]
    fn write_acq(&mut self, val: u64) {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.acq as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_cmbloc(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.cmbloc as usize) };
        mem.read()
    }

    #[inline]
    fn write_cmbloc(&mut self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.cmbloc as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_cmbsz(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.cmbsz as usize) };
        mem.read()
    }

    #[inline]
    fn write_cmbsz(&mut self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.cmbsz as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_bpinfo(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.bpinfo as usize) };
        mem.read()
    }

    #[inline]
    fn write_bpinfo(&mut self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.bpinfo as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_bprsel(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.bprsel as usize) };
        mem.read()
    }

    #[inline]
    fn write_bprsel(&mut self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.bprsel as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_bpmbl(&self) -> u64 {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.bpmbl as usize) };
        mem.read()
    }

    #[inline]
    fn write_bpmbl(&mut self, val: u64) {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.bpmbl as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_cmbmsc(&self) -> u64 {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.cmbmsc as usize) };
        mem.read()
    }

    #[inline]
    fn write_cmbmsc(&mut self, val: u64) {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.cmbmsc as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_cmbsts(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.cmbsts as usize) };
        mem.read()
    }

    #[inline]
    fn read_pmrcap(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.pmrcap as usize) };
        mem.read()
    }

    #[inline]
    fn read_pmrctl(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.pmrctl as usize) };
        mem.read()
    }

    #[inline]
    fn write_pmrctl(&mut self, val: u32) {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.pmrctl as usize) };
        mem.write(val)
    }

    #[inline]
    fn read_pmrsts(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.pmrsts as usize) };
        mem.read()
    }

    #[inline]
    fn read_pmrebs(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.pmrebs as usize) };
        mem.read()
    }

    #[inline]
    fn read_pmrswtp(&self) -> u32 {
        let mem: VolAddress<u32> = unsafe { VolAddress::new(self.pmrswtp as usize) };
        mem.read()
    }

    #[inline]
    fn read_pmrmsc(&self) -> u64 {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.pmrmsc as usize) };
        mem.read()
    }

    #[inline]
    fn write_pmrmsc(&mut self, val: u64) {
        let mem: VolAddress<u64> = unsafe { VolAddress::new(self.pmrmsc as usize) };
        mem.write(val)
    }

    #[inline]
    fn write_adm_sub_tail_queue_doorbell(&mut self, val: u16) {
        debug!(
            "Writing to adm submission tail doorbel at memaddr {:X}h: {:X}h",
            self.adm_sub_tail_queue_doorbell, val
        );
        let mem: VolAddress<u16> =
            unsafe { VolAddress::new(self.adm_sub_tail_queue_doorbell as usize) };
        mem.write(val)
    }

    #[inline]
    fn write_adm_comp_head_queue_doorbell(&mut self, val: u16) {
        debug!(
            "Writing to adm completion head doorbel at memaddr {:X}h: {:X}h",
            self.adm_comp_head_queue_doorbell, val
        );
        let mem: VolAddress<u16> =
            unsafe { VolAddress::new(self.adm_comp_head_queue_doorbell as usize) };
        mem.write(val)
    }

    #[inline]
    fn write_sub_tail_doorbell(&mut self, doorbell: usize, val: u16) {
        if self.sub_tail_queue_doorbells.len() > doorbell {
            debug!(
                "Writing to submission tail doorbel at memaddr {:X}h: {:X}h",
                self.sub_tail_queue_doorbells[doorbell], val
            );
            let mem: VolAddress<u16> =
                unsafe { VolAddress::new(self.sub_tail_queue_doorbells[doorbell] as usize) };
            mem.write(val);
        }
    }

    #[inline]
    fn write_comp_head_doorbell(&mut self, doorbell: usize, val: u16) {
        if self.comp_head_queue_doorbells.len() > doorbell {
            debug!(
                "Writing to completion head doorbel at memaddr {:X}h: {:X}h",
                self.comp_head_queue_doorbells[doorbell], val
            );
            let mem: VolAddress<u16> =
                unsafe { VolAddress::new(self.comp_head_queue_doorbells[doorbell] as usize) };
            mem.write(val);
        }
    }

    async fn init(&mut self) {
        // 1. Verify controller version
        info!("initializing controller");
        info!("running controller checks");
        info!("Checking controller version");
        let vs = self.read_vs();
        self.version = Semver::new(
            vs.get_bits(16..32) as u64,
            vs.get_bits(8..16) as u64,
            vs.get_bits(0..8) as u64,
        );
        info!("NVMe version: {}", self.version);
        info!("Checking command set support");
        if self.read_cap().get_bit(37) {
            info!("NVM command set supported");
        } else if self.read_cap().get_bit(44) {
            warn!("Controller only supports administrative commands");
        } else if self.read_cap().get_bit(37) && self.read_cap().get_bit(44) {
            info!("Device supports both NVM and admin-only command sets");
        }
        // 2. Verify minimum page size matches the system one
        let mpsmin = {
            let min: u32 = 12 + (self.read_cap().get_bits(48..52) as u32);
            2_u64.pow(min)
        };
        if mpsmin == 4096 {
            info!("device supports 4KiB pages");
        } else {
            error!("device does not support 4KiB pages");
            return;
        }
        let mut nvme_error_count = 0;
        'nvme_init: loop {
            if nvme_error_count > 2 {
                error!("Critical controller reset failure; aborting initialization");
                return;
            }
            // 3. Reset controller
            info!("resetting controller");
            let mut cc = self.read_cc();
            if cc.get_bit(0) {
                cc.set_bit(0, false);
            }
            self.write_cc(cc);
            // 4. Wait for reset to complete
            loop {
                if !self.read_csts().get_bit(0) {
                    break;
                }
                if self.read_csts().get_bit(1) {
                    warn!("Fatal controller error; attempting reset");
                    nvme_error_count += 1;
                    continue 'nvme_init;
                }
            }
            info!("reset complete");
            // 5. Configure admin queue
            info!("Configuring queues");
            let mut aqa = self.read_aqa();
            if self.read_cap().get_bits(0..16) > 4095 {
                info!(
                    "Max queue entry limit exceeds 4095 (is {}); restricting",
                    self.read_cap().get_bits(0..16)
                );
                aqa.set_bits(16..29, 4095);
                aqa.set_bits(0..12, 4095);
            } else {
                info!(
                    "Max queue entry limit for admin queue is {}",
                    self.read_cap().get_bits(0..16)
                );
                aqa.set_bits(16..28, self.read_cap().get_bits(0..16) as u32);
                aqa.set_bits(0..12, self.read_cap().get_bits(0..16) as u32);
            }
            self.write_aqa(aqa);
            info!("AQA configured; allocating admin queue");
            let asqsize = if self.read_cap().get_bits(0..16) > 4095 {
                4096
            } else {
                self.read_cap().get_bits(0..16) + 1
            };
            let acqsize = if self.read_cap().get_bits(0..16) > 4095 {
                4096
            } else {
                self.read_cap().get_bits(0..16) + 1
            };
            let asqaddr = get_aligned_free_addr(
                (size_of::<queues::SubmissionQueueEntry>() as u64) * asqsize,
                4096,
            );
            let acqaddr = get_aligned_free_addr(
                (size_of::<queues::CompletionQueueEntry>() as u64) * acqsize,
                4096,
            );
            info!(
                "allocating memory for ASQ, {} bytes",
                (size_of::<queues::SubmissionQueueEntry>() as u64) * asqsize
            );
            if !allocate_phys_range(asqaddr, asqaddr + asqsize, false) {
                error!("Cannot allocate SQS!");
                return;
            }
            self.sqs
                .push(queues::SubmissionQueue::new(asqaddr, asqsize as u16));
            info!(
                "Allocating memory for ACQ, {} bytes",
                (size_of::<queues::CompletionQueueEntry>() as u64) * acqsize
            );
            if !allocate_phys_range(acqaddr, acqaddr + acqsize, false) {
                error!("Cannot allocate CQS!");
                return;
            }
            self.cqs
                .push(queues::CompletionQueue::new(acqaddr, acqsize as u16));
            info!("ASQ located at {:X}", asqaddr);
            self.write_asq(asqaddr);
            info!("ACQ located at {:X}", acqaddr);
            self.write_acq(acqaddr);
            // 6. Configure the controller
            info!("enabling controller");
            let mut cc = self.read_cc();
            // A. Configure I/O queue entry size
            cc.set_bits(20..24, 4); // I/O Completion Queue Entry Size, 1 << 4 = 16
            cc.set_bits(16..20, 6); // I/O Submission Queue Entry Size, 1 << 6 = 64
                                    // B. Configure shutdown notification
            cc.set_bits(14..16, 0); // Shutdown Notification, 0 = no notification
                                    // C. Configure arbitration mechanism
            cc.set_bits(11..14, 0); // Arbitration Mechanism Selected, 0 = round-robin
                                    // D. Configure memory page size
            cc.set_bits(7..11, 0); // Memory Page Size, 0 = (2^(12+0)) = 4096
                                   // E. Configure the I/O command set that is to be used
            if self.read_cap().get_bit(37) {
                cc.set_bits(4..7, 0); // 0 = NVM command set
            } else if self.read_cap().get_bit(44) {
                cc.set_bits(4..7, 7); // 7 = Admin command set only
            }
            cc.set_bits(1..4, 0); // reserved
                                  // F. Enable the controller
            cc.set_bit(0, true); // Enable
            self.write_cc(cc);
            loop {
                if self.read_csts().get_bit(0) {
                    break 'nvme_init;
                }
                if self.read_csts().get_bit(1) {
                    warn!("Fatal controller error; attempting reset");
                    free_range(
                        asqaddr,
                        if self.read_cap().get_bits(0..16) > 4095 {
                            asqaddr + 0x3FFC0
                        } else {
                            asqaddr + self.read_cap().get_bits(0..16)
                        },
                    );
                    free_range(
                        acqaddr,
                        if self.read_cap().get_bits(0..16) > 4095 {
                            acqaddr + 0xFFF0
                        } else {
                            acqaddr + self.read_cap().get_bits(0..16)
                        },
                    );
                    nvme_error_count += 1;
                    continue 'nvme_init;
                }
            }
        }
        info!("Controller enabled");
        // 8. Send identify command
        info!("Sending identify command");
        match self.identify(0, 0, 0x01, 0, 0).await {
            Ok(r) => match r {
                IdentifyResponse::IdController(response) => {
                    let vid = response.vid;
                    let ssvid = response.ssvid;
                    info!("Vendor ID: {:X}, subsystem vendor ID: {:X}", vid, ssvid);
                    let sn = response.sn;
                    let sn = String::from_utf8_lossy(&sn);
                    info!("Serial number: {}", sn);
                    let mn = response.mn;
                    let mn = String::from_utf8_lossy(&mn);
                    info!("Model number: {}", mn);
                    let fr = response.fr;
                    let fr = String::from_utf8_lossy(&fr);
                    info!("Firmware revision: {}", fr);
                    let rab = response.rab;
                    info!("RAB: {:X}h", 2 << (rab - 1));
                    let fguid = response.fguid;
                    info!("FRU GUID: {:X}", fguid);
                    let tnvmcap = response.tnvmcap;
                    let unvmcap = response.unvmcap;
                    info!(
                        "NVM capacity total: {}; unallocated NVM capacity: {}",
                        tnvmcap, unvmcap
                    );
                    let subnqn = response.subnqn;
                    let subnqn = String::from_utf8_lossy(&subnqn);
                    info!("NVMe qualified name: {}", subnqn);
                }
                e => {
                    error!("Received response: {:?}", e);
                }
            },
            e => {
                error!("Command returned non-success status: {:?}", e);
            }
        }
    }
}

impl Disk for NvmeController {
    type CommandRequest = Request;
    type Response = Response;
    type Error = queues::Status;
    fn process_command(
        &mut self,
        req: Self::CommandRequest,
    ) -> Result<Self::Response, Self::Error> {
        self.sqs[req.qid].queue_command(req.entry);
        if req.qid == 0 {
            self.write_adm_sub_tail_queue_doorbell(self.sqs[req.qid].get_queue_tail());
        } else {
            self.write_sub_tail_doorbell(req.qid, self.sqs[req.qid].get_queue_tail());
        }
        {
            loop {
                hlt();
                if let Some(i) = INTRS.try_read() {
                    if i[self.intrspos].1 > 0 {
                        break;
                    }
                }
            }
        }
        disable_interrupts();
        let mut i = INTRS.write();
        let mut entries: MiniVec<queues::CompletionQueueEntry> = MiniVec::new();
        self.cqs[req.qid].read_new_entries(&mut entries);
        i[self.intrspos].1 -= 1;
        if req.qid == 0 {
            self.write_adm_comp_head_queue_doorbell(self.cqs[req.qid].get_queue_head());
        } else {
            self.write_comp_head_doorbell(req.qid, self.cqs[req.qid].get_queue_head());
        }
        if entries.len() > 1 {
            warn!(
                "Retrieved {} responses; returning only first",
                entries.len()
            );
            entries.truncate(1);
        }
        let entry = entries[0];
        enable_interrupts();
        if entry.status.sc != 0x00 {
            Err(entry.status)
        } else {
            Ok(Response {
                qid: req.qid,
                entry,
            })
        }
    }

    fn process_commands(&mut self, reqs: MiniVec<Self::CommandRequest>) -> MiniVec<Self::Response> {
        reqs.iter()
            .for_each(|req| self.sqs[req.qid].queue_command(req.entry));
        reqs.iter().for_each(|req| {
            if req.qid == 0 {
                self.write_adm_sub_tail_queue_doorbell(self.sqs[req.qid].get_queue_tail());
            } else {
                self.write_sub_tail_doorbell(req.qid, self.sqs[req.qid].get_queue_tail());
            }
        });
        {
            loop {
                hlt();
                if let Some(i) = INTRS.try_read() {
                    if (i[self.intrspos].1 as usize) != reqs.len() {
                        continue;
                    } else {
                        break;
                    }
                }
            }
        }
        disable_interrupts();
        let mut i = INTRS.write();
        let mut entries: MiniVec<Self::Response> = MiniVec::with_capacity(65536);
        reqs.iter().for_each(|req| {
            let mut resps: MiniVec<queues::CompletionQueueEntry> = MiniVec::with_capacity(65536);
            self.cqs[req.qid].read_new_entries(&mut resps);
            resps.shrink_to_fit();
            while let Some(r) = resps.pop() {
                entries.push(Response {
                    qid: req.qid,
                    entry: r,
                });
            }
            if req.qid == 0 {
                self.write_adm_comp_head_queue_doorbell(self.cqs[req.qid].get_queue_head());
            } else {
                self.write_comp_head_doorbell(req.qid, self.cqs[req.qid].get_queue_head());
            }
        });
        i[self.intrspos].1 -= reqs.len() as u16;
        enable_interrupts();
        entries
    }
}

/// Initializes an NVMe controller
pub async fn init(dev: PciDevice) {
    info!(
        "Registering interrupt handler for interrupt {}",
        dev.int_line
    );
    register_interrupt_handler(
        dev.int_line,
        Box::new(move |_| {
            INTRS
                .write()
                .iter_mut()
                .filter(|(id, _)| dev.unique_dev_id == *id)
                .for_each(|(_, i)| *i += 1)
        }),
    );
    let idx = {
        info!("Creating queue");
        let mut devices = INTRS.write();
        devices.push((dev.unique_dev_id, 0));
        devices.len() - 1
    };
    let mut controllers = CONTROLLERS.lock();
    let controller = unsafe { NvmeController::new(dev, idx).await };
    if let Some(c) = controller {
        controllers.push(c);
    } else {
        error!("Cannot add NVMe controller");
        return;
    }
}

fn init_rand() -> Hc128Rng {
    let mut seed: [u8; 32] = [0; 32];
    let rand = RdRand::new().unwrap();
    let mut count = 0;
    while let Some(i) = rand.get_u64() {
        let bytes = u64::to_le_bytes(i);
        count += 8;
        if count == 32 {
            break;
        }
        seed.iter_mut()
            .skip(count)
            .zip(bytes.iter())
            .for_each(|(s, b)| *s = *b);
    }
    Hc128Rng::from_seed(seed)
}
